// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple mos -O2 -emit-llvm %s -o - | FileCheck %s

struct Small { int a, b; };
struct Large { long a, b; };

// CHECK-LABEL: @test_small_struct_param(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue [[STRUCT_SMALL:%.*]] poison, i16 [[S_COERCE0:%.*]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT:%.*]] = insertvalue [[STRUCT_SMALL]] [[DOTFCA_0_INSERT]], i16 [[S_COERCE1:%.*]], 1
// CHECK-NEXT:    ret [[STRUCT_SMALL]] [[DOTFCA_1_INSERT]]
//
struct Small test_small_struct_param(struct Small s) {
  return s;
}

// CHECK-LABEL: @test_large_struct_param(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.memcpy.p0.p0.i16(ptr noundef nonnull align 1 dereferenceable(8) [[AGG_RESULT:%.*]], ptr noundef nonnull align 1 dereferenceable(8) [[S:%.*]], i16 8, i1 false), !tbaa.struct [[TBAA_STRUCT2:![0-9]+]]
// CHECK-NEXT:    ret void
//
struct Large test_large_struct_param(struct Large s) {
  return s;
}

// CHECK-LABEL: @test_small_struct_vaarg(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[LIST:%.*]] = alloca ptr, align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 2, ptr nonnull [[LIST]]) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    call void @llvm.va_start(ptr nonnull [[LIST]])
// CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[LIST]], align 1
// CHECK-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i16 4
// CHECK-NEXT:    store ptr [[ARGP_NEXT]], ptr [[LIST]], align 1
// CHECK-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load i16, ptr [[ARGP_CUR]], align 1, !tbaa.struct [[TBAA_STRUCT7:![0-9]+]]
// CHECK-NEXT:    [[RETVAL_SROA_2_0_ARGP_CUR_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i16 2
// CHECK-NEXT:    [[RETVAL_SROA_2_0_COPYLOAD:%.*]] = load i16, ptr [[RETVAL_SROA_2_0_ARGP_CUR_SROA_IDX]], align 1, !tbaa.struct [[TBAA_STRUCT10:![0-9]+]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 2, ptr nonnull [[LIST]]) #[[ATTR6]]
// CHECK-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue [[STRUCT_SMALL:%.*]] poison, i16 [[RETVAL_SROA_0_0_COPYLOAD]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT:%.*]] = insertvalue [[STRUCT_SMALL]] [[DOTFCA_0_INSERT]], i16 [[RETVAL_SROA_2_0_COPYLOAD]], 1
// CHECK-NEXT:    ret [[STRUCT_SMALL]] [[DOTFCA_1_INSERT]]
//
struct Small test_small_struct_vaarg(int x, ...) {
  __builtin_va_list list;
  __builtin_va_start(list, x);
  return __builtin_va_arg(list, struct Small);
}

// CHECK-LABEL: @test_large_struct_vaarg(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[LIST:%.*]] = alloca ptr, align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 2, ptr nonnull [[LIST]]) #[[ATTR6]]
// CHECK-NEXT:    call void @llvm.va_start(ptr nonnull [[LIST]])
// CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[LIST]], align 1
// CHECK-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i16 2
// CHECK-NEXT:    store ptr [[ARGP_NEXT]], ptr [[LIST]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARGP_CUR]], align 1
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i16(ptr noundef nonnull align 1 dereferenceable(8) [[AGG_RESULT:%.*]], ptr noundef nonnull align 1 dereferenceable(8) [[TMP0]], i16 8, i1 false), !tbaa.struct [[TBAA_STRUCT2]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 2, ptr nonnull [[LIST]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
struct Large test_large_struct_vaarg(int x, ...) {
  __builtin_va_list list;
  __builtin_va_start(list, x);
  return __builtin_va_arg(list, struct Large);
}
